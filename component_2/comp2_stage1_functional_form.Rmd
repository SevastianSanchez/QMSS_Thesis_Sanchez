---
title: "comp2_stage2_functional_form"
output: html_document
---

```{r}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 60) 
)
```

##*[IGNORE ALL BELOW]*
## MODEL MISSPECIFICATION CHECKS [Stage 1]
================================================================================
Following standard econometric practice, I first establish the appropriate functional form for main effects, using RESET tests and residual diagnostics, before testing for theoretically motivated interaction effects.

## RESET Test for Misspecification [STAGE 1]
The RESET test checks for omitted variable bias by testing if the squared and cubed fitted values significantly improve the model fit. If the p-value is low (typically < 0.05), it suggests that the model may be misspecified, indicating that a non-linear relationship or omitted variables are present.

When you get a p-value of less than 0.05 this means that you reject the null hypothesis - this means that statistically your model is better with first order terms.
```{r eval=FALSE, include=FALSE}
# transforming to base R lm()
ols_spi_di <- lm(spi_comp ~ di_score_lag1 + log_gdppc + factor(income_level_recoded) + factor(year), data = panel_data_s1) # regular linear model
fd_spi_di <- lm(spi_diff ~ di_diff_lag1 + log_gdppc_diff + factor(income_level_recoded), data = fd_data)
fe_spi_di <- lm(spi_comp ~ di_score_lag1 + log_gdppc + factor(income_level_recoded) + factor(year) + factor(country_code), data = panel_data_s1)

# Performing RESET tests for the base models
resettest(ols_spi_di, power = 2:3, type = "regressor", 
          vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))
resettest(fd_spi_di, power = 2:3, type = "regressor",
          vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))
resettest(fe_spi_di, power = 2:3, type = "regressor",
          vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))

# Saving results to a dataframe
s1_reset_results <- data.frame(
  model = c("ols_spi_di", "fd_spi_di", "fe_spi_di"),
  F_statistic = c(resettest(ols_spi_di, power = 2:3, type = "regressor", 
                             vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$statistic,
                  resettest(fd_spi_di, power = 2:3, type = "regressor",
                             vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$statistic,
                  resettest(fe_spi_di, power = 2:3, type = "regressor",
                             vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$statistic),
  p_value = c(resettest(ols_spi_di, power = 2:3, type = "regressor", 
                        vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$p.value,
              resettest(fd_spi_di, power = 2:3, type = "regressor",
                        vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$p.value,
              resettest(fe_spi_di, power = 2:3, type = "regressor",
                        vcov = function(x) vcovHC(x, cluster = "group", type = "HC1"))$p.value)
)
print(s1_reset_results)
# Save the results to a CSV file
write.csv(s1_reset_results, file = "results_csv/s1_reset_results.csv", row.names = FALSE)
```
We reject the Null Hypothesis of no misspecification in the relationship between DI and SPI performance, as the p-value is greater than 0.05 in in the FE model. This suggests that non-linear terms may make a significant contribution to the model.

## Stepwise Check: Applying Polynomial Terms [Stage 1]
For this section, all continuous predictors (DI & Log(GDP)) are centered for simplicity and to avoid multicollinearity issues. 

- **H0:** The relationship between SPI and DI performance is linear.
- **H1:** The relationship between SPI and DI performance is non-linear (quadratic or cubic).
```{r eval=FALSE, include=FALSE}
# No quadratic Terms Applied - Baseline 
fe_spi_di_base <- plm(formula = spi_comp ~ cen_di_score_lag1 + log_gdppc + factor(income_level_recoded) + factor(year),
               model = "within", 
               index = c("country_code", "year"),
               data = panel_data_s1)
rob_sum_base <-summary(fe_spi_di_base, vcov = vcovHC(fe_spi_di_base, cluster = "group", type = "HC1"))

# + Quadratic terms for DI
fe_quads_s1_m2 <- plm(formula = spi_comp ~ cen_di_score_lag1 + cen_di_score_lag1_sq + cen_log_gdppc + factor(income_level_recoded) + factor(year),
               model = "within", 
               index = c("country_code", "year"),
               data = panel_data_s1)
rob_sum_m2 <- summary(fe_quads_s1_m2, vcov = vcovHC(fe_quads_s1_m2, cluster = "group", type = "HC1"))

# + Quadratic terms for DI and Log(GDP)
fe_quads_s1_m3 <- plm(formula = spi_comp ~ cen_di_score_lag1 + cen_di_score_lag1_sq
                      + cen_log_gdppc + cen_log_gdppc_sq + factor(income_level_recoded) + factor(year),
               model = "within", 
               index = c("country_code", "year"),
               data = panel_data_s1)
rob_sum_m3 <- summary(fe_quads_s1_m3, vcov = vcovHC(fe_quads_s1_m3, cluster = "group", type = "HC1"))

# + Cubic terms for DI and Log(GDP)
fe_cubics_s1_m4 <- plm(formula = spi_comp ~ cen_di_score_lag1 + cen_di_score_lag1_sq + cen_di_score_lag1_cub + cen_log_gdppc + cen_log_gdppc_sq + cen_log_gdppc_cub + factor(income_level_recoded) + factor(year),
               model = "within", 
               index = c("country_code", "year"),
               data = panel_data_s1)
rob_sum_m4 <- summary(fe_cubics_s1_m4, vcov = vcovHC(fe_cubics_s1_m4, cluster = "group", type = "HC1"))

# Extracting robust standard errors for each model
rob_se_base <- coeftest(fe_spi_di_base, vcov = vcovHC(fe_spi_di_base, cluster = "group", type = "HC1"))
rob_se_m2  <- coeftest(fe_quads_s1_m2, vcov = vcovHC(fe_quads_s1_m2, cluster = "group", type = "HC1"))
rob_se_m3  <- coeftest(fe_quads_s1_m3, vcov = vcovHC(fe_quads_s1_m3, cluster = "group", type = "HC1"))
rob_se_m4 <- coeftest(fe_cubics_s1_m4, vcov = vcovHC(fe_cubics_s1_m4, cluster = "group", type = "HC1"))

# stargazer table
library(stargazer)
stargazer(fe_spi_di_base, fe_quads_s1_m2, fe_quads_s1_m3, fe_cubics_s1_m4, 
          se = list(rob_se_base[, 2], rob_se_m2[, 2], rob_se_m3[, 2], rob_se_m4[, 2]
                    ),
          title = "Applying Polynomial Terms to Stage 1 Models",
          align = TRUE,
          dep.var.labels = "SPI Overall Score",
          column.labels = c("FE Base", "Quad DI", "Quad DI+GDP", "Cubic DI+GDP"),
          #covariate.labels = c("SPI", "SPI Squared", "DI", "DI Squared",
          #                     "Log GDPpc", "Log GDPpc Squared", "Intercept"),
          notes = "All models apply fixed effects. Robust standard errors clustered by country in parentheses",
          type = "html",  # Change to "latex" for LaTeX output or "html" for Word
          report = "vcs*",  # Shows significance stars and standard errors
          model.numbers = FALSE,
          keep.stat = c("n", "rsq", "adj.rsq"),
          out = "figures/poly_s1_models.html") #saved as html

# AIC/BIC function
source('function/plm_aic_bic_function.R')
plm_aic_bic(rob_sum_base) # regular FE
plm_aic_bic(rob_sum_m2) # quadratic FE
plm_aic_bic(rob_sum_m3) # quadratic FE
plm_aic_bic(rob_sum_m4) # cubic FE
```

DI: We fail to reject the null hypothesis of linearity in the relationship between DI and SPI performance, as the p-value is greater than 0.05 in all models. Although literature suggests a non-linear relationship (SOURCE), the results here do not support it. 

# MODEL DIAGNOSTICS [Stage 1]

## Multicollinearity Assessment and Correction [Stage 2] 
### [CHECK BACK W GREG - NEED TO FIGURE OUT WHAT TO DO WITH THIS]
The only model worth looking for multicollinearity is the base model, as the other models have no polynomial or interaction terms.
```{r eval=FALSE, include=FALSE}
# converting to base R lm() for VIF calculation
ols_spi_di <- lm(spi_comp ~ di_score_lag1 + log_gdppc + factor(income_level_recoded) + factor(year), data = panel_data_s1) # regular linear model
fe_spi_di <- lm(spi_comp ~ di_score_lag1 + log_gdppc + factor(income_level_recoded) + factor(year) + factor(country_code), data = panel_data_s1)

vif(ols_spi_di)
vif(fe_spi_di)

# Check for multicollinearity using VIF
vif_results <- vif(fe_spi_di)
# Convert VIF results to a data frame for better readability
vif_df <- data.frame(
  stage = "Stage 1",
  variable = names(vif_results),
  VIF = vif_results
)
print(vif_df)
# Save VIF results to a CSV file
write.csv(vif_df, file = "results_csv/s1_vif_results.csv", row.names = FALSE)
# The VIF values are all below 5, indicating no significant multicollinearity issues.
```
