---
title: "correlation_matrix_SDG_SPI"
author: "Sevastian Sanchez"
date: "`r Sys.Date()`"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Correlation Matrix: Stage 1 & 2 predictors 
create correlation matrix for SDG score, SPI score, DI score and log GDP per capita
```{r}
# Load necessary libraries
library(plm)
library(ggplot2)
library(reshape2)
library(dplyr)
library(car)  # For VIF calculation

# set working directory
setwd("~/Documents/GitHub/QMSS_Thesis_Sanchez")

#load libraries/packages
source("packages.R")

# load data
source("Comp2_panel_wrangling.R")

# Extract the data 
corr_data <- all_data %>%
  dplyr::select(sdg_overall, spi_comp, sci_overall, di_score, log_gdppc, income_level, population, country_name, country_code, year, goal1:goal17, p1_use, p2_services, p3_products, p4_sources, p5_infra)

```

# VIF Test: Stage 1 & 2 predictors
```{r}
# Libraries
library(plm)
library(car)  

# Calculate VIF for the predictors in the panel data
vif_data <- corr_data %>%
  dplyr::filter(year >= 2016) %>%
  dplyr::select(sdg_overall, spi_comp, di_score, log_gdppc, year, income_level, population)

# Stage 1 Models 
# Fit a linear model to assess multicollinearity
vif_model_s1 <- lm(spi_comp ~ di_score + log_gdppc + factor(year), data = vif_data)
# Calculate VIF
vif_values_s1 <- vif(vif_model_s1)
# Print VIF values
vif_values_s1

# Stage 2 Models 
# Fit a linear model to assess multicollinearity
vif_model_s2 <- lm(sdg_overall ~ spi_comp + di_score + log_gdppc + factor(year) + factor(income_level), data = vif_data)
# Calculate VIF
vif_values_s2 <- vif(vif_model_s2)
# Print VIF values
vif_values_s2
```


# Main Variables Matrix
```{r}
  # Impute missing data: log_gdppc
corr_data_impute <- corr_data %>%
  dplyr::filter(year >= 2016) %>%
  mutate(
    log_gdppc = ifelse(is.na(log_gdppc), median(log_gdppc, na.rm = TRUE), log_gdppc), 
    population = ifelse(is.na(population), median(population, na.rm = TRUE), population)
  )

# Calculate the correlation matrix
correlation_matrix <- cor(corr_data_impute[, c("sdg_overall", "spi_comp", "sci_overall", "di_score", "log_gdppc", "population")], use = "pairwise.complete.obs")

# Convert the correlation matrix to a data frame for ggplot
melted_correlation <- melt(correlation_matrix)

# Visualize the correlation matrix using ggplot2
correlation_plot <- ggplot(data = melted_correlation, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile(color = "black") +
  scale_fill_gradient2(
    low = "orange", mid = "white", high = "steelblue", midpoint = 0,
    limits = c(-1, 1), name = "Correlation"
  ) +
  geom_text(aes(label = round(value, 2)), color = "black", size = 3) +
  theme_minimal() +
  labs(title = "Main Variables (2016-2023)", subtitle = "Correlation Matrix",
       x = "", y = "") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

# Show the correlation plot
correlation_plot

# save the plot
ggsave("figures/correlation_matrix_main_vars.png", plot = correlation_plot, width = 5, height = 4, dpi = 300)

```

# Correlation Matrix: SDG Disaggregated scores (2005-2023)
```{r}
# Extract the data for SDG disaggregated scores
sdg_data <- corr_data %>%
  dplyr::filter(year >= 2005) %>%
  dplyr::select(country_name, country_code, year, goal1:goal17)

# Calculate the correlation matrix for SDG disaggregated scores
correlation_matrix_sdg <- cor(sdg_data[, -c(1, 2, 3)], use = "pairwise.complete.obs")

# Convert matrix to df
melted_cor_sdg <- melt(correlation_matrix_sdg)

# build matrix using ggplot and change names from goal1, goal2, ... to goal 1, goal 2, ...
correlation_plot_sdg <- ggplot(data = melted_cor_sdg, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile(color = "black") +
  scale_fill_gradient2(
    low = "orange", mid = "white", high = "steelblue", midpoint = 0,
    limits = c(-1, 1), name = "Correlation"
  ) +
  geom_text(aes(label = round(value, 2)), color = "black", size = 2.5) +
  theme_minimal() +
  labs(title = "SDG Disaggregated Scores (2005-2023)",
       x = "", y = "", subtitle = "Correlation Matrix") +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Show the correlation plot for SDG disaggregated scores
correlation_plot_sdg

# save
ggsave("figures/correlation_matrix_sdg_disaggregated.png", plot = correlation_plot_sdg, width = 6, height = 5, dpi = 300)
```


# Partial Correlation Matrix: Disaggregated SDG ~ SCI Scores 
```{r cars}
matrix_data <- corr_data %>%
  dplyr::filter(year >= 2016) %>% 
  dplyr::select(country_name, country_code, year, goal1:goal17, p1_use, p2_services, p3_products, p4_sources, p5_infra)

# Calculate the correlation matrix for SDG disaggregated scores
correlation_matrix_sdg <- cor(sdg_data[, -c(1, 2, 3)], use = "pairwise.complete.obs")

#Impute missing data: log_gdppc & population 
matrix_data <- matrix_data %>%
  mutate(
    log_gdppc = ifelse(is.na(log_gdppc), median(log_gdppc, na.rm = TRUE), log_gdppc),
    population = ifelse(is.na(population), median(population, na.rm = TRUE), population)
  )
```

#Partial correlation & package 
Partial correlation controls for confounding variables: Ensures correlations between SPI pillars and SDG goals are adjusted for external factors like log(GDP) and population.

Focuses on Direct Relationships: Removes indirect effects of controls on both SPI and SDG metrics.

# Initialize an empty matrix to store results
```{r}
spi_pillars <- c("spi_comp", "p1_use", "p2_services", "p3_products", "p4_sources", "p5_infra")
sdg_goals <- c("sdg_overall", paste0("goal", 1:17))

#devise matrix 
partial_corr_matrix <- matrix(NA, nrow = length(spi_pillars), 
                              ncol = length(sdg_goals),
                              dimnames = list(spi_pillars, sdg_goals))

for (spi in spi_pillars) {
  for (sdg in sdg_goals) {
    # Subset data with controls
    temp_data <- matrix_data[, c(spi, sdg, "log_gdppc", "population")] %>%
      na.omit()
    
    # Skip if insufficient data
    if (nrow(temp_data) < 10) {
      partial_corr_matrix[spi, sdg] <- NA
      next
    }
    
    # Check for near-constant variables (threshold)
    var_check <- sapply(temp_data[, c("log_gdppc", "population")], var)
    if (any(var_check < 0.01)) {  # Increased from 1e-3 to 0.01
      partial_corr_matrix[spi, sdg] <- NA
      next
    }
    
    # Attempt 1: Standard partial correlation
    tryCatch({
      result <- ppcor::pcor(temp_data)
      partial_corr_matrix[spi, sdg] <- result$estimate[1, 2]
    }, error = function(e) {
      # Attempt 2: Pseudoinverse-based correlation (more robust)
      tryCatch({
        cov_mat <- cov(temp_data)
        pcor_mat <- corpcor::pcor.shrink(temp_data, verbose = FALSE)
        partial_corr_matrix[spi, sdg] <- pcor_mat[1, 2]
      }, error = function(e) {
        # Fallback: Simple correlation without controls
        cor_value <- cor(temp_data[, spi], temp_data[, sdg])
        partial_corr_matrix[spi, sdg] <- cor_value
      })
    })
  }
}

# Convert to data frame
matrix_df <- as.data.frame(partial_corr_matrix)

# Reshape the matrix into long format
melted_cormat <- melt(partial_corr_matrix)
```

#visualizing partial correlation matrix
```{r}
matrix_spi_sdg <- ggplot(data = melted_cormat, aes(x = Var2, y = Var1, fill = value)) +
  geom_tile(color = "white") +
  scale_fill_gradient2(
    low = "red", mid = "white", high = "darkgreen", midpoint = 0,
    limits = c(-1, 1), name = "Correlation"
  ) +
  # Grey tiles for NA values (plot FIRST to avoid covering text)
  geom_tile(
    data = subset(melted_cormat, is.na(value)),
    aes(x = Var2, y = Var1), fill = "grey90", color = "white"
  ) +
  # Text with dynamic color based on |value|
  geom_text(
    aes(
      label = ifelse(is.na(value), "", round(value, 2)),
      color = abs(value) > 0.5  # White text for |cor| > 0.5
    ),
    size = 2.5
  ) +
  scale_color_manual(
    guide = "none",  # Hide the color legend
    values = c("black", "white")  # FALSE = black, TRUE = white
  ) +
  theme_minimal() +
  labs(
    title = "Partial Correlation Matrix: SPI Pillars vs SDG Goals",
    x = "SDG Goals", 
    y = "SPI Pillars"
  ) +
  theme(
    axis.text.x = element_text(angle = 45, hjust = 1, size = 9),
    axis.text.y = element_text(size = 9),
    legend.position = "right"
  ) +
  coord_fixed()  # Maintain square aspect ratio

#show
matrix_spi_sdg
```

